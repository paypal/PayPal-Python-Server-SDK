# -*- coding: utf-8 -*-

"""
paypalserversdk

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from paypalserversdk.api_helper import APIHelper
from paypalserversdk.models.cycle_execution import CycleExecution
from paypalserversdk.models.failed_payment_details import FailedPaymentDetails
from paypalserversdk.models.last_payment_details import LastPaymentDetails
from paypalserversdk.models.money import Money


class SubscriptionBillingInformation(object):

    """Implementation of the 'Subscription Billing Information' model.

    The billing details for the subscription. If the subscription was or is
    active, these fields are populated.

    Attributes:
        outstanding_balance (Money): The currency and amount for a financial
            transaction, such as a balance or payment due.
        cycle_executions (List[CycleExecution]): The trial and regular billing
            executions.
        last_payment (LastPaymentDetails): The details for the last payment.
        next_billing_time (str): The date and time, in [Internet date and time
            format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds
            are required while fractional seconds are optional. Note: The
            regular expression provides guidance but does not reject all
            invalid dates.
        final_payment_time (str): The date and time, in [Internet date and
            time format](https://tools.ietf.org/html/rfc3339#section-5.6).
            Seconds are required while fractional seconds are optional. Note:
            The regular expression provides guidance but does not reject all
            invalid dates.
        failed_payments_count (int): The number of consecutive payment
            failures. Resets to `0` after a successful payment. If this
            reaches the `payment_failure_threshold` value, the subscription
            updates to the `SUSPENDED` state.
        last_failed_payment (FailedPaymentDetails): The details for the failed
            payment of the subscription.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "outstanding_balance": 'outstanding_balance',
        "failed_payments_count": 'failed_payments_count',
        "cycle_executions": 'cycle_executions',
        "last_payment": 'last_payment',
        "next_billing_time": 'next_billing_time',
        "final_payment_time": 'final_payment_time',
        "last_failed_payment": 'last_failed_payment'
    }

    _optionals = [
        'cycle_executions',
        'last_payment',
        'next_billing_time',
        'final_payment_time',
        'last_failed_payment',
    ]

    def __init__(self,
                 outstanding_balance=None,
                 failed_payments_count=None,
                 cycle_executions=APIHelper.SKIP,
                 last_payment=APIHelper.SKIP,
                 next_billing_time=APIHelper.SKIP,
                 final_payment_time=APIHelper.SKIP,
                 last_failed_payment=APIHelper.SKIP):
        """Constructor for the SubscriptionBillingInformation class"""

        # Initialize members of the class
        self.outstanding_balance = outstanding_balance 
        if cycle_executions is not APIHelper.SKIP:
            self.cycle_executions = cycle_executions 
        if last_payment is not APIHelper.SKIP:
            self.last_payment = last_payment 
        if next_billing_time is not APIHelper.SKIP:
            self.next_billing_time = next_billing_time 
        if final_payment_time is not APIHelper.SKIP:
            self.final_payment_time = final_payment_time 
        self.failed_payments_count = failed_payments_count 
        if last_failed_payment is not APIHelper.SKIP:
            self.last_failed_payment = last_failed_payment 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        outstanding_balance = Money.from_dictionary(dictionary.get('outstanding_balance')) if dictionary.get('outstanding_balance') else None
        failed_payments_count = dictionary.get("failed_payments_count") if dictionary.get("failed_payments_count") else None
        cycle_executions = None
        if dictionary.get('cycle_executions') is not None:
            cycle_executions = [CycleExecution.from_dictionary(x) for x in dictionary.get('cycle_executions')]
        else:
            cycle_executions = APIHelper.SKIP
        last_payment = LastPaymentDetails.from_dictionary(dictionary.get('last_payment')) if 'last_payment' in dictionary.keys() else APIHelper.SKIP
        next_billing_time = dictionary.get("next_billing_time") if dictionary.get("next_billing_time") else APIHelper.SKIP
        final_payment_time = dictionary.get("final_payment_time") if dictionary.get("final_payment_time") else APIHelper.SKIP
        last_failed_payment = FailedPaymentDetails.from_dictionary(dictionary.get('last_failed_payment')) if 'last_failed_payment' in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(outstanding_balance,
                   failed_payments_count,
                   cycle_executions,
                   last_payment,
                   next_billing_time,
                   final_payment_time,
                   last_failed_payment)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'outstanding_balance={self.outstanding_balance!r}, '
                f'cycle_executions={(self.cycle_executions if hasattr(self, "cycle_executions") else None)!r}, '
                f'last_payment={(self.last_payment if hasattr(self, "last_payment") else None)!r}, '
                f'next_billing_time={(self.next_billing_time if hasattr(self, "next_billing_time") else None)!r}, '
                f'final_payment_time={(self.final_payment_time if hasattr(self, "final_payment_time") else None)!r}, '
                f'failed_payments_count={self.failed_payments_count!r}, '
                f'last_failed_payment={(self.last_failed_payment if hasattr(self, "last_failed_payment") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'outstanding_balance={self.outstanding_balance!s}, '
                f'cycle_executions={(self.cycle_executions if hasattr(self, "cycle_executions") else None)!s}, '
                f'last_payment={(self.last_payment if hasattr(self, "last_payment") else None)!s}, '
                f'next_billing_time={(self.next_billing_time if hasattr(self, "next_billing_time") else None)!s}, '
                f'final_payment_time={(self.final_payment_time if hasattr(self, "final_payment_time") else None)!s}, '
                f'failed_payments_count={self.failed_payments_count!s}, '
                f'last_failed_payment={(self.last_failed_payment if hasattr(self, "last_failed_payment") else None)!s})')
