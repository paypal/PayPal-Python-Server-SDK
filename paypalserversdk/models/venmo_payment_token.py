"""paypalserversdk.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

# ruff: noqa: E501
from paypalserversdk.api_helper import APIHelper
from paypalserversdk.models.address import Address
from paypalserversdk.models.name import Name
from paypalserversdk.models.phone_with_type import (
    PhoneWithType,
)
from paypalserversdk.models.vaulted_digital_wallet_shipping_details import (
    VaultedDigitalWalletShippingDetails,
)


class VenmoPaymentToken(object):
    """Implementation of the 'Venmo Payment Token' model.

    Full representation of a Venmo Payment Token.

    Attributes:
        description (str): The description displayed to the consumer on the approval
            flow for a digital wallet, as well as on the merchant view of the payment
            token management experience. exp: PayPal.com.
        usage_pattern (UsagePattern): Expected business/charge model for the billing
            agreement.
        shipping (VaultedDigitalWalletShippingDetails): The shipping details.
        permit_multiple_payment_tokens (bool): Create multiple payment tokens for the
            same payer, merchant/platform combination. Use this when the customer has
            not logged in at merchant/platform. The payment token thus generated, can
            then also be used to create the customer account at merchant/platform.
            Use this also when multiple payment tokens are required for the same
            payer, different customer at merchant/platform. This helps to identify
            customers distinctly even though they may share the same PayPal account.
            This only applies to PayPal payment source.
        usage_type (PaypalPaymentTokenUsageType): The usage type associated with a
            digital wallet payment token.
        customer_type (PaypalPaymentTokenCustomerType): The customer type associated
            with a digital wallet payment token. This is to indicate whether the
            customer acting on the merchant / platform is either a business or a
            consumer.
        email_address (str): The internationalized email
            address.<blockquote><strong>Note:</strong> Up to 64 characters are
            allowed before and 255 characters are allowed after the <code>@</code>
            sign. However, the generally accepted maximum length for an email address
            is 254 characters. The pattern verifies that an unquoted <code>@</code>
            sign exists.</blockquote>
        payer_id (str): The account identifier for a PayPal account.
        name (Name): The name of the party.
        phone (PhoneWithType): The phone information.
        address (Address): The portable international postal address. Maps to
            [AddressValidationMetadata](https://github.com/googlei18n/libaddressinput/
            wiki/AddressValidationMetadata) and HTML 5.1 [Autofilling form controls:
            the autocomplete
            attribute](https://www.w3.org/TR/html51/sec-forms.html#autofilling-form-co
            ntrols-the-autocomplete-attribute).
        user_name (str): The Venmo username, as chosen by the user.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "description": "description",
        "usage_pattern": "usage_pattern",
        "shipping": "shipping",
        "permit_multiple_payment_tokens": "permit_multiple_payment_tokens",
        "usage_type": "usage_type",
        "customer_type": "customer_type",
        "email_address": "email_address",
        "payer_id": "payer_id",
        "name": "name",
        "phone": "phone",
        "address": "address",
        "user_name": "user_name",
    }

    _optionals = [
        "description",
        "usage_pattern",
        "shipping",
        "permit_multiple_payment_tokens",
        "usage_type",
        "customer_type",
        "email_address",
        "payer_id",
        "name",
        "phone",
        "address",
        "user_name",
    ]

    def __init__(
        self,
        description=APIHelper.SKIP,
        usage_pattern=APIHelper.SKIP,
        shipping=APIHelper.SKIP,
        permit_multiple_payment_tokens=False,
        usage_type=APIHelper.SKIP,
        customer_type=APIHelper.SKIP,
        email_address=APIHelper.SKIP,
        payer_id=APIHelper.SKIP,
        name=APIHelper.SKIP,
        phone=APIHelper.SKIP,
        address=APIHelper.SKIP,
        user_name=APIHelper.SKIP):
        """Initialize a VenmoPaymentToken instance."""
        # Initialize members of the class
        if description is not APIHelper.SKIP:
            self.description = description
        if usage_pattern is not APIHelper.SKIP:
            self.usage_pattern = usage_pattern
        if shipping is not APIHelper.SKIP:
            self.shipping = shipping
        self.permit_multiple_payment_tokens = permit_multiple_payment_tokens
        if usage_type is not APIHelper.SKIP:
            self.usage_type = usage_type
        if customer_type is not APIHelper.SKIP:
            self.customer_type = customer_type
        if email_address is not APIHelper.SKIP:
            self.email_address = email_address
        if payer_id is not APIHelper.SKIP:
            self.payer_id = payer_id
        if name is not APIHelper.SKIP:
            self.name = name
        if phone is not APIHelper.SKIP:
            self.phone = phone
        if address is not APIHelper.SKIP:
            self.address = address
        if user_name is not APIHelper.SKIP:
            self.user_name = user_name

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        description =\
            dictionary.get("description")\
            if dictionary.get("description")\
                else APIHelper.SKIP
        usage_pattern =\
            dictionary.get("usage_pattern")\
            if dictionary.get("usage_pattern")\
                else APIHelper.SKIP
        shipping =\
            VaultedDigitalWalletShippingDetails.from_dictionary(
                dictionary.get("shipping"))\
                if "shipping" in dictionary.keys()\
                else APIHelper.SKIP
        permit_multiple_payment_tokens =\
            dictionary.get("permit_multiple_payment_tokens")\
            if dictionary.get("permit_multiple_payment_tokens")\
                else False
        usage_type =\
            dictionary.get("usage_type")\
            if dictionary.get("usage_type")\
                else APIHelper.SKIP
        customer_type =\
            dictionary.get("customer_type")\
            if dictionary.get("customer_type")\
                else APIHelper.SKIP
        email_address =\
            dictionary.get("email_address")\
            if dictionary.get("email_address")\
                else APIHelper.SKIP
        payer_id =\
            dictionary.get("payer_id")\
            if dictionary.get("payer_id")\
                else APIHelper.SKIP
        name =\
            Name.from_dictionary(
                dictionary.get("name"))\
                if "name" in dictionary.keys()\
                else APIHelper.SKIP
        phone =\
            PhoneWithType.from_dictionary(
                dictionary.get("phone"))\
                if "phone" in dictionary.keys()\
                else APIHelper.SKIP
        address =\
            Address.from_dictionary(
                dictionary.get("address"))\
                if "address" in dictionary.keys()\
                else APIHelper.SKIP
        user_name =\
            dictionary.get("user_name")\
            if dictionary.get("user_name")\
                else APIHelper.SKIP

        # Return an object of this model
        return cls(description,
                   usage_pattern,
                   shipping,
                   permit_multiple_payment_tokens,
                   usage_type,
                   customer_type,
                   email_address,
                   payer_id,
                   name,
                   phone,
                   address,
                   user_name)

    def __repr__(self):
        """Return a unambiguous string representation."""
        _description=(
            self.description
            if hasattr(self, "description")
            else None
        )
        _usage_pattern=(
            self.usage_pattern
            if hasattr(self, "usage_pattern")
            else None
        )
        _shipping=(
            self.shipping
            if hasattr(self, "shipping")
            else None
        )
        _permit_multiple_payment_tokens=(
            self.permit_multiple_payment_tokens
            if hasattr(self, "permit_multiple_payment_tokens")
            else None
        )
        _usage_type=(
            self.usage_type
            if hasattr(self, "usage_type")
            else None
        )
        _customer_type=(
            self.customer_type
            if hasattr(self, "customer_type")
            else None
        )
        _email_address=(
            self.email_address
            if hasattr(self, "email_address")
            else None
        )
        _payer_id=(
            self.payer_id
            if hasattr(self, "payer_id")
            else None
        )
        _name=(
            self.name
            if hasattr(self, "name")
            else None
        )
        _phone=(
            self.phone
            if hasattr(self, "phone")
            else None
        )
        _address=(
            self.address
            if hasattr(self, "address")
            else None
        )
        _user_name=(
            self.user_name
            if hasattr(self, "user_name")
            else None
        )
        return (
            f"{self.__class__.__name__}("
            f"description={_description!r}, "
            f"usage_pattern={_usage_pattern!r}, "
            f"shipping={_shipping!r}, "
            f"permit_multiple_payment_tokens={_permit_multiple_payment_tokens!r}, "
            f"usage_type={_usage_type!r}, "
            f"customer_type={_customer_type!r}, "
            f"email_address={_email_address!r}, "
            f"payer_id={_payer_id!r}, "
            f"name={_name!r}, "
            f"phone={_phone!r}, "
            f"address={_address!r}, "
            f"user_name={_user_name!r}, "
            f")"
        )

    def __str__(self):
        """Return a human-readable string representation."""
        _description=(
            self.description
            if hasattr(self, "description")
            else None
        )
        _usage_pattern=(
            self.usage_pattern
            if hasattr(self, "usage_pattern")
            else None
        )
        _shipping=(
            self.shipping
            if hasattr(self, "shipping")
            else None
        )
        _permit_multiple_payment_tokens=(
            self.permit_multiple_payment_tokens
            if hasattr(self, "permit_multiple_payment_tokens")
            else None
        )
        _usage_type=(
            self.usage_type
            if hasattr(self, "usage_type")
            else None
        )
        _customer_type=(
            self.customer_type
            if hasattr(self, "customer_type")
            else None
        )
        _email_address=(
            self.email_address
            if hasattr(self, "email_address")
            else None
        )
        _payer_id=(
            self.payer_id
            if hasattr(self, "payer_id")
            else None
        )
        _name=(
            self.name
            if hasattr(self, "name")
            else None
        )
        _phone=(
            self.phone
            if hasattr(self, "phone")
            else None
        )
        _address=(
            self.address
            if hasattr(self, "address")
            else None
        )
        _user_name=(
            self.user_name
            if hasattr(self, "user_name")
            else None
        )
        return (
            f"{self.__class__.__name__}("
            f"description={_description!s}, "
            f"usage_pattern={_usage_pattern!s}, "
            f"shipping={_shipping!s}, "
            f"permit_multiple_payment_tokens={_permit_multiple_payment_tokens!s}, "
            f"usage_type={_usage_type!s}, "
            f"customer_type={_customer_type!s}, "
            f"email_address={_email_address!s}, "
            f"payer_id={_payer_id!s}, "
            f"name={_name!s}, "
            f"phone={_phone!s}, "
            f"address={_address!s}, "
            f"user_name={_user_name!s}, "
            f")"
        )
